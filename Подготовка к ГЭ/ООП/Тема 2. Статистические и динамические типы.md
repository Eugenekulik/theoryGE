- **Статические методы. Ключевое слово static**

	Статические методы определяют общее для всех объектов поведение, которое не зависит от конкретного объекта. Для обращения к статическим методам также применяется имя класса. Следует учитывать, что статические методы могут обращаться только к статическим членам класса.
	Чтобы объявить метод как статический используется ключевое слово *static*.
	
	*Статический конструктор*
	Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты:
	- Статические конструкторы не должны иметь модификатор доступа и не принимают параметров
	- Как и в статических методах, в статических конструкторах нельзя использовать ключевое слово this для ссылки на текущий объект класса и можно обращаться только к статическим членам класса
	- Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса или при первом обращении к его статическим членам (если таковые имеются)
	
	Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз.
- **Статические классы**

	Статические классы объявляются с модификатором static и могут содержать только статические поля, свойства и методы.
	Пример:
	```c#
	static class Operations
	{
	    public static int Add(int x, int y) => x + y;
	    public static int Subtract(int x, int y) => x - y;
	    public static int Multiply(int x, int y) => x * y;
	}
	```
	
- **Отображение статического метода на диаграмме**

	Для отображения статического метода на диаграмме, используется подчеркивание.
	![[static_method_uml.png]]
- **Паттерны проектирования и их классификация**
	Источник: https://refactoring.guru/ru/design-patterns

	Паттерны (или шаблоны) проектирования описывают типичные способы решения часто встречающихся проблем при проектировании программ.
	
	Паттерны отличаются по уровню сложности, охвата и детализации проектируемой системы. Кроме этого, их можно поделить на три группы, относительно решаемых проблем.
	
	Самые низкоуровневые и простые паттерны — _идиомы_. Они не универсальны, поскольку применимы только в рамках одного языка программирования.
	
	Самые универсальные — _архитектурные паттерны_, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.
	Кроме того, паттерны отличаются и предназначением. Выделяют три группы:
	-   *Порождающие паттерны* беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
	-   *Структурные паттерны* показывают различные способы построения связей между объектами.
	-   *Поведенческие паттерны* заботятся об эффективной коммуникации между объектами.
- **Описание паттерна Singleton**

	**Одиночка** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
	Одиночка решает сразу две проблемы, нарушая _принцип единственной ответственности_ класса.
	1. **Гарантирует наличие единственного экземпляра класса**. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.
		Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.
	    
	    Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса **всегда** возвращает новый объект.
	2. **Предоставляет глобальную точку доступа**. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.
	    
	    Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.
- **Ключевое слово dynamic**

	Хотя C# относится к статически типизированным языкам, в последних версиях языка были добавлены некоторые динамические возможности. Так, начиная с .NET 4.0 была добавлена новая функциональность под названием DLR (Dynamic Language Runtime). DLR представляет среду выполнения динамических языков, например, таких языков как IronPython и IronRuby.

	Чтобы понять значение данного нововведение, нужно осознавать разичие между языками со статической и динамической типизицией. В языках со статической типизацией выявление всех типов и их членов - свойств и методов происходит на этапе компиляции. А в динамических языках системе ничего не известно о свойствах и методах типов вплоть до выполнения.

	Благодаря этой среде DLR C# может создавать динамические объекты, члены которых выявляются на этапе выполнения программы, и использовать их вместе с традиционными объектами со статической типизацией.

	Ключевым моментом использования DLR в C# является применение типов dynamic. Это ключевое слово позволяет опустить проверку типов во время компиляции. Кроме того, объекты, объявленные как dynamic, могут в течение работы программы менять свой тип.
	```c#
	dynamic obj = 3;            // здесь obj - целочисленное int
	Console.WriteLine(obj);     // 3
 
	obj = "Hello world";        // obj - строка
	Console.WriteLine(obj);     // Hello world
 
	obj = new Person("Tom", 37); // obj - объект Person
	Console.WriteLine(obj);      // Person { Name = Tom, Age = 37 }
 
	record class Person(string Name, int Age);
	```
	Несмотря на то, что переменная x меняет тип своего значения несколько раз, данный код будет нормально работать. В этом использование типов dynamic отличается от применения ключевого слова var. Для переменной, объявленной с помощью ключевого слова var, тип выводится во время компиляции и затем во время выполнения больше не меняется.

	Также можно найти общее между использованием dynamic и типом object. Если в предыдущем примере мы заменим dynamic на object: object x = 3;, то результат будет тот же. Однако и тут есть различия. 
	```c#
	object obj = 24;
	dynamic dyn = 24;
	obj += 4; // так нельзя
	dyn += 4; // а так можно
	```
	