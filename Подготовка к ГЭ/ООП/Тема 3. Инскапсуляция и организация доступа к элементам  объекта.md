- **Реализация принципа инкапсуляции в языке C#**

	Инкапсуляция - это возможность (механизм) с помощью которой мы можем спрятать от конечного пользователя реализацию того или иного метода, устройства объекта и так далее и представить в пользование только то, что необходимо для работы, обеспечив тем самым целостность объекта.
	Таким образом при разработке класса,  мы скрываем его реализацию, предоставляя только определенный API, для работы с ним, защищая таким образом зависимость клиента от реализации.
	Инкапсуляция в C# реализуется с помощью модификаторов доступа.
- **Модификаторы доступа private, public, internal. Доступ к членам класса по умолчанию.** 

	Все поля, методы и остальные компоненты класса имеют модификаторы доступа. Модификаторы доступа позволяют задать допустимую область видимости для компонентов класса. То есть модификаторы доступа определяют контекст, в котором можно употреблять данную переменную или метод.
	В языке C# применяются следующие модификаторы доступа:
	- private: закрытый или приватный компонент класса или структуры. Приватный компонент доступен только в рамках своего класса или структуры.
	- private protected: компонент класса доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.
	- file: добавлен в версии C# 11 и применяется к типам, например, классам и структурам. Класс или структура с такми модификатором доступны только из текущего файла кода.
	- protected: такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
	- internal: компоненты класса или структуры доступен из любого места кода в той же сборке, однако он недоступен для других программ и сборок.
	- protected internal: совмещает функционал двух модификаторов protected и internal. Такой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.
	- public: публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в коде, а также из других программ и сборок.
	По умолчанию доступ к членам класса private.
- **Частичные классы, ключевое слово partial.**

	Классы могут быть частичными. То есть мы можем иметь несколько файлов с определением одного и того же класса, и при компиляции все эти определения будут скомпилированы в одно.

	Например, определим в проекте два файла с кодом. Не столь важно как эти файлы будут называться. Например, PersonBase.cs и PersonAdditional.cs. В одном из этих файлов (без разницы в каком именно) определим следующий класс:
	```c#
	public partial class Person
	{
		public void Move()
		{
			Console.WriteLine("I am moving");
		}
	}
	```
	А в другом файле определим следующий класс:
	```c#
	public partial class Person
	{
		public void Eat()
	    {
	        Console.WriteLine("I am eating");
	    }
	}
	```
	Таким образом, два файла в проекте содержит определение одного и того же класса Person, которые содержат два разных метода. И оба определенных здесь класса являются частичными. Для этого они определяются с ключевым словом partial.
	
	*Частичные методы*
	Частичные классы могут содержать частичные методы. Такие методы также опреляются с ключевым словом partial. Причем определение частичного метода без тела метода находится в одном частичном классе, а реализация этого же метода - в другом частичном классе.

	Например, изменим выше определенные классы Person. Первый класс:
	```c#
	public partial class Person
	{
	    partial void Read();
	    public void DoSomething()
	    {
	        Read();
	    }
	}
	```
	Второй класс:
	```
	public partial class Person
	{
	    partial void Read()
	    {
	        Console.WriteLine("I am reading a book");
	    }
	}
	```
	В первом классе определен метод Read(). Причем на момент определения первого класса неизвестно, что представляет собой этот метод, какие действия он будет выполнять. Тем не менее мы знаем список его параметров и можем вызвать в первом классе. Второй класс уже непосредственно определяет тело метода Read().